# cdktf kubernetes

- hashicorp tf tut: [https://developer.hashicorp.com/terraform/tutorials/cdktf/cdktf-applications](https://developer.hashicorp.com/terraform/tutorials/cdktf/cdktf-applications)
- my repo:

[https://github.com/bronifty/cdktf-kubernetes](https://github.com/bronifty/cdktf-kubernetes)

1. Start a local Docker registry to store container images

```tsx
docker run -d --restart always -p "127.0.0.1:5000:5000" --name local-registry registry:2
```

1. use kind to create a kubernetes cluster running in Docker locally

```tsx
kind create cluster --name=cdktf-app --config kind-config.yaml
```

1. verify cluster by listing kind clusters

```tsx
kind get clusters
```

1. use kubectl to print out info about your cluster; context is kind- followed by your cluster name

```tsx
kubectl cluster-info --context=kind-cdktf-app
```

1. create kubeconfig file to allow access to kubernetes cluster

```tsx
kubectl config view --raw --context kind-cdktf-app > kubeconfig.yaml
```

1. attach your local Docker registry to your kind cluster
    1. Docker registry name is local-registry
    2. kind cluster network name is kind
    3. This command puts the local-registry on the kind network
    4. Another way of thinking of this is: the kind kubernetes cluster network has the docker registry attached to it

```tsx
docker network connect kind local-registry
```

1. configure your Kubernetes cluster to use the local registry

```tsx
kubectl apply -f local-registry-configmap.yaml --kubeconfig kubeconfig.yaml
```

- With the config-map, KIND uses docker registry to store and retrieve docker images
- Now we will use cdktf to generate images for our app & deploy to KIND
    - I’m guessing this is like asset archive except image type sent to the docker registry rather than put in s3 bucket

1. cdktf init a new TS app with a preset provider type of kubernetes 
    1. Inside this app dir, convert the root repo’s k8s deployment into cdktf from tf in order to use it as a stack and deploy… the deployment

```tsx
mkdir app && cd app

cdktf init --template=typescript \
             --project-name=learn-terraform-cdktf-applications \
             --project-description="Learn how to develop CDKTF applications" \
             --providers="kubernetes@~>2.14" \
             --local

cat ../k8s_deployment.tf | cdktf convert  --provider=kubernetes
```

1. convert the cdktf converted code from tf into something usable for a stack (cdktf is alpha, so it’s not fully usable ootb you have to customize it)
    1. So the following code will be converted and put into main.ts, the app dir’s stack file (main app file)

```tsx
// code generated by the cdktf convert command above
/*Provider bindings are generated by running cdktf get.
See https://cdk.tf/provider-generation for more details.*/
import * as kubernetes from "./.gen/providers/kubernetes";
new kubernetes.deployment.Deployment(this, "myapp", {
  metadata: {
    labels: {
      app: "myapp",
      component: "frontend",
      environment: "dev",
    },
    name: "myapp-frontend-dev",
  },
  spec: {
    replicas: "1",
    selector: {
      matchLabels: {
        app: "myapp",
        component: "frontend",
        environment: "dev",
      },
    },
    template: {
      metadata: {
        labels: {
          app: "myapp",
          component: "frontend",
          environment: "dev",
        },
      },
      spec: {
        container: [
          {
            image: "nginx:latest",
            name: "myapp-frontend-dev",
          },
        ],
      },
    },
  },
});
```

```tsx
// main.tf file code which is customizing the converted code
/*Provider bindings are generated by running cdktf get.
See https://cdk.tf/provider-generation for more details.*/
// import * as kubernetes from "./.gen/providers/kubernetes";
import * as kubernetes from "@cdktf/provider-kubernetes";
import * as path from "path";
import { Construct } from "constructs";
import { App, TerraformStack } from "cdktf";

class MyStack extends TerraformStack {
  constructor(scope: Construct, id: string) {
    super(scope, id);

    // define resources here

    new kubernetes.provider.KubernetesProvider(this, "kind", {
      configPath: path.join(__dirname, "../kubeconfig.yaml"),
    });

    new kubernetes.deployment.Deployment(this, "myapp", {
      metadata: {
        labels: {
          app: "myapp",
          component: "frontend",
          environment: "dev",
        },
        name: "myapp",
      },
      spec: {
        replicas: "1",
        selector: {
          matchLabels: {
            app: "myapp",
            component: "frontend",
            environment: "dev",
          },
        },
        template: {
          metadata: {
            labels: {
              app: "myapp",
              component: "frontend",
              environment: "dev",
            },
          },
          spec: {
            container: [
              {
                image: "nginx:latest",
                name: "frontend",
              },
            ],
          },
        },
      },
    });
  }
}

const app = new App();
new MyStack(app, "app");
app.synth();
```

1. let’s go ahead and yarn this thing to get all the deps (including path, which for whatever reason doesn’t come ootb)
    1. cdktf synth command will generate TF config in json format from the cdktf code
        1. As a review, we originally converted tf file to cdktf, to then convert it back to tf.json (TF ⇒ CDKTF ⇒ TF.json)
    2. reviewing output of synth at app/cdktf.out/stacks/app/cdk.tf.json
2. deploy it

```tsx
cdktf deploy
// yes to prompt allow it
```

1. list deployments with kubectl 

```tsx
kubectl get deployments
// myapp 1/1
```

### Notes on Kubernetes Deployment

- deployment manages replicasets (container image and number of them)
    - manages rolling updates to pods including versioning and rollbacks
    - HA / autoscaling

1. update main.ts increase replicas in replicaset of deployment from 1 to 4
2. cdktf deploy
3. kubectl get deployments

```tsx
NAME    READY   UP-TO-DATE   AVAILABLE   AGE
myapp   4/4     4            4           8m31s
```

1. Refactor to use Constructs
    1. KubernetesWebAppDeployment
    2. KubernetesNodePortService
2. Test
3. Destroy
4. Refactor Constructs
    1. combine the deployment and nodeport into one app called SimpleKubernetesWebApp
5. Create custom image and push to local registry in docker
    1. build, tag, push
6. Now do it for backend

```tsx
"scripts": {
    "start": "node backend.js",
    "build": "docker build . -t nocorp-backend",
    "tag": "docker tag nocorp-backend:latest localhost:5000/nocorp-backend:latest",
    "push": "docker push localhost:5000/nocorp-backend:latest",
    "deploy": "npm run build && npm run tag && npm run push"
  },
```

```tsx
// main.ts
/*Provider bindings are generated by running cdktf get.
See https://cdk.tf/provider-generation for more details.*/
// import * as kubernetes from "./.gen/providers/kubernetes";
import * as kubernetes from "@cdktf/provider-kubernetes";
import * as path from "path";
import { Construct } from "constructs";
import { App, TerraformStack } from "cdktf";
import { SimpleKubernetesWebApp } from "./constructs";

class MyStack extends TerraformStack {
  constructor(scope: Construct, id: string) {
    super(scope, id);

    // define resources here

    new kubernetes.provider.KubernetesProvider(this, "kind", {
      configPath: path.join(__dirname, "../kubeconfig.yaml"),
    });

    const app_backend = new SimpleKubernetesWebApp(this, "app_backend", {
      image: "localhost:5000/nocorp-backend:latest",
      replicas: 1,
      port: 30002,
      app: "myapp",
      component: "backend",
      environment: "dev",
    });

    new SimpleKubernetesWebApp(this, "app_frontend", {
      image: "localhost:5000/nocorp-frontend:latest",
      replicas: 2,
      port: 30001,
      app: "myapp",
      component: "frontend",
      environment: "dev",
      env: { BACKEND_APP_URL: `http://localhost:${app_backend.config.port}` },
    });
  }
}

const app = new App();
new MyStack(app, "app");
app.synth();
```

1. Refactor App Stack
    1. swap the hardcoded values for args passed in at runtime

```tsx
// main.tf
/*Provider bindings are generated by running cdktf get.
See https://cdk.tf/provider-generation for more details.*/
// import * as kubernetes from "./.gen/providers/kubernetes";
import * as kubernetes from "@cdktf/provider-kubernetes";
import * as path from "path";
import { Construct } from "constructs";
import { App, TerraformStack } from "cdktf";
import {
  SimpleKubernetesWebApp,
  SimpleKubernetesWebAppConfig,
} from "./constructs";

// class MyStack extends TerraformStack {
//   constructor(scope: Construct, id: string) {
//     super(scope, id);

//     // define resources here

//     new kubernetes.provider.KubernetesProvider(this, "kind", {
//       configPath: path.join(__dirname, "../kubeconfig.yaml"),
//     });

//     const app_backend = new SimpleKubernetesWebApp(this, "app_backend", {
//       image: "localhost:5000/nocorp-backend:latest",
//       replicas: 1,
//       port: 30002,
//       app: "myapp",
//       component: "backend",
//       environment: "dev",
//     });

//     new SimpleKubernetesWebApp(this, "app_frontend", {
//       image: "localhost:5000/nocorp-frontend:latest",
//       replicas: 2,
//       port: 30001,
//       app: "myapp",
//       component: "frontend",
//       environment: "dev",
//       env: { BACKEND_APP_URL: `http://localhost:${app_backend.config.port}` },
//     });
//   }
// }
class MyStack extends TerraformStack {
  constructor(
    scope: Construct,
    name: string,
    config: {
      frontend: SimpleKubernetesWebAppConfig;
      backend: SimpleKubernetesWebAppConfig;
    }
  ) {
    super(scope, name);

    new kubernetes.provider.KubernetesProvider(this, "kind", {
      configPath: path.join(__dirname, "../kubeconfig.yaml"),
    });

    const app_backend = new SimpleKubernetesWebApp(
      this,
      "app_backend",
      config.backend
    );
    new SimpleKubernetesWebApp(this, "app_frontend", {
      ...config.frontend,
      env: { BACKEND_APP_URL: `http://localhost:${app_backend.config.port}` },
    });
  }
}

const app = new App();
new MyStack(app, "app", {
  frontend: {
    image: "localhost:5000/nocorp-frontend:latest",
    replicas: 2,
    port: 30001,
    app: "myapp",
    component: "frontend",
    environment: "dev",
  },
  backend: {
    image: "localhost:5000/nocorp-backend:latest",
    replicas: 1,
    port: 30002,
    app: "myapp",
    component: "backend",
    environment: "dev",
  },
});
app.synth();
```

1. Add a second stack
    1. add a stack to represent your test env

```tsx
new MyStack(app, 'app-test', {
  frontend: {
    image: 'localhost:5000/nocorp-frontend:latest',
    replicas: 4,
    port: 30003,
    app: 'myapp',
    component: 'frontend',
    environment: 'test',
  },
  backend: {
    image: 'localhost:5000/nocorp-backend:latest',
    replicas: 2,
    port: 30004,
    app: 'myapp',
    component: 'backend',
    environment: 'test',
  },
})
```

- now that you have multiple stacks, you must specify a stack when you run cdktf commands

```tsx
cdktf deploy app-test
```

- since each stack is a separate tf project with separate state, you can deploy, update, and destroy them independently

```tsx
kubectl get deployments
NAME                  READY   UP-TO-DATE   AVAILABLE   AGE
myapp-backend-dev     1/1     1            1           48m
myapp-backend-test    2/2     2            2           97s
myapp-frontend-dev    2/2     2            2           49m
myapp-frontend-test   4/4     4            4           97s
```

- clean up

```tsx
cdktf destroy app-test
>approve
cdktf destroy app
>approve
kind delete cluster --name=cdktf-app
docker stop local-registry
docker rm local-registry
```

References:

- [https://www.hashicorp.com/blog/cdk-for-terraform-in-production-learning-from-pocket](https://www.hashicorp.com/blog/cdk-for-terraform-in-production-learning-from-pocket)